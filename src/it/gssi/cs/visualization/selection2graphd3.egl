[%var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");%]

<head>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</head>
<style>

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

.node circle {
  /*fill: black;*/
  fill: #00000059;
  stroke: #fff;
  stroke-width: 1.5px;
}

.node.Metamodel circle {
  /*fill: black;*/
  fill: #00000029;
  stroke: #fff;
  stroke-width: 1.5px;
}

.node.Model circle{
fill:blue;
  stroke: #fff;
}

circle.virtual{

fill:#ccc;
}

path.link.dependency {
  stroke: red;
}

path.link.distance {
  stroke: violet;
  
}

text {
  font: 10px sans-serif;
  pointer-events: none;
}

 div.tooltip {
                position: absolute;
                text-align: center;
                width: 500px;
                height: 15px;
                padding: 8px;
                font: 10px sans-serif;
                background: lightgray;
                border: solid 1px #aaa;
                border-radius: 8px;
                pointer-events: none;
			
            }
            
.jumbotron {
background-color:#FFFFFF;
}

</style>
<body>

<div class="container">

      <!-- Static navbar -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">Repository Explorer</a>
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li><a href="#" class="select-activelayer" data-layerid="A::A">Reset</a></li>
              [%for (a	 in nodes.eClass.name.asSet()) { %]
				<li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">[%=a%] <span class="caret"></span></a>
                <ul class="dropdown-menu">
                [%for (qa in evals.qa.select(q|q.subject.name==a).name.asSet()) { %]
                  <li><a href="#" class="select-activelayer" data-layerid="[%=a%]::[%=qa%]">[%=qa%]</a></li>   
                  [%}%]          
             </ul>
              </li>
				[%}%]
            </ul>
            
          </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
      </nav>

      <!-- Main component for a primary marketing message or call to action -->
      <div class="jumbotron" id="repo">
        
      </div>

    </div> <!-- /container -->

<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var links = [
[%for (edge in edges) { 
if(edge.src.isDefined() and edge.trg.isDefined()){
%]
  {source: "[%=edge.src.name%]", target: "[%=edge.trg.name%]", type: "unidirectional", relationtype: "[%=edge.eClass.name%]", value: "[%=(edge.eClass.name='Distance')?edge.value:''%]"},
  [%
 	}}
  %]
];

var subject = "[%=subject.name%]";   
var nodes = {
[%for (node in nodes) { %]
	"[%=node.name%]" : {"name":"[%=node.name%]","type":"[%=node.eClass.name%]","info":"[%=node.name%]","virtual":"[%=(node.virtual)?"virtual":"concrete"%]" 
	[% if(evals.size()>0){ %]
	,
	[% for(e in evals.select(ev|emfTool.EcoreUtil.equals(node, ev.subject))){ %]
	 "[%=e.qa.name%]":"[%=e.actualizedvalue%]",
	 [%}%]
	[%}%]	 
	},
[%}%]

 };

var width = 600,
    height = 400;

const MIN_LINK_DISTANCE = 100,
	  MIN_NODE_SIZE = 5, MAX_NODE_SIZE = 50;

let ACTIVELAYER = "A::A";
let [TYPE_PROPERTY, SIZE_PROPERTY] = ACTIVELAYER.split("::")

let MAX_VALUE, MIN_VALUE;

const getMaxMinValuesFromNodes = (nodes) => {
	//default values
	const default_values = [0, 100]
	let parse_nodes;
  	//can be used either nodes object or force.nodes() array
  	Array.isArray(nodes) ?  parse_nodes = nodes : parse_nodes = Object.values(nodes)

	const filter_array = parse_nodes.filter(item => item.type == TYPE_PROPERTY ? +item[SIZE_PROPERTY] : null)
	
	//check if there are enough objects with valid SIZE_PROPERTY values
	//check if there are enough objects with valid SIZE_PROPERTY values
	if(filter_array.length < 2){
		return [100, 100]
	}

	const sorted_array = filter_array.sort((prev, current) => prev[SIZE_PROPERTY] - current[SIZE_PROPERTY])
	const min = +sorted_array[0][SIZE_PROPERTY], max = +sorted_array[sorted_array.length-1][SIZE_PROPERTY]

	return min && max ? [min, max] : default_values
}

//get integer number between
const getRelativeValue = (n, round) => {
	//relativeValue is not required when there is ony one elements
	if(MAX_VALUE === MIN_VALUE){
		return n
	}
	return round ? Math.round((n*MAX_NODE_SIZE)/MAX_VALUE) : (n*MAX_NODE_SIZE)/MAX_VALUE
}
//get a valid numeric value from SIZE_PROPERTY property 
const getNodeSize = d => {	
	const value = d[SIZE_PROPERTY], type = d.type;

	//check type, if it's not TYPE_PROPERTY return default size
	if(type !== TYPE_PROPERTY){
		return MIN_NODE_SIZE
	}
	
	//type is ok, then node's size depends on d.SIZE_PROPERTY's value

	//check if value is a number, null or undefined
	const num = +value ? +value : 0;
	
	
//get relative value if MIN_VALUE != MAX_VALUE 
	const rel = MIN_VALUE === MAX_VALUE ? 0 : getRelativeValue(num)
	return rel + MIN_NODE_SIZE
}

//set distance for each edge, adding an offset based on nodes' size
const linkDistanceByNodeSize = d => {
	let offset = 0;

	//get source node offset
	const source_offset = getNodeSize(d.source)
	if(source_offset > MIN_NODE_SIZE) offset += source_offset

	//get target node offset
	const target_offset = getNodeSize(d.target)
	if(target_offset > MIN_NODE_SIZE) offset += target_offset

	return offset + MIN_LINK_DISTANCE
}

//init min and max values
[MIN_VALUE, MAX_VALUE] = getMaxMinValuesFromNodes(nodes)

links.forEach(function(link) {
    link.source = nodes[link.source] || 
        (nodes[link.source] = {name: link.source});
    link.target = nodes[link.target] || 
        (nodes[link.target] = {name: link.target});
    link.value = +link.value;
});



var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    //.linkDistance(60)
    .linkDistance(linkDistanceByNodeSize)
    .charge(-400)
    //.charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("div#repo").append("svg")
    .attr("width", width)
    .attr("height", height);

// build the arrow.
svg.append("svg:defs").selectAll("marker")
    .data(["end"])      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    //.attr("refX", 15)
    //.attr("refY", -1.5) 
    .attr("refX", 0)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

// add the links and the arrows
var path = svg.append("svg:g").selectAll("path")
    .data(force.links())
  .enter().append("svg:path")
    .attr("class", function(d) { return "link " + d.relationtype; })
    //.attr("class", "link")
     .attr("id", (d, i) => "path_" + i)
  .style("stroke-dasharray", ("3, 3"))
 .attr("marker-end", link => link.type === "unidirectional" ? "url(#end)" : 0)
 ;
 
//TEXTPATH
svg.append("g").selectAll("text")
.data(force.links())
.enter()
.append("text")
.append("textPath")
.attr("xlink:href", (d,i) => "#path_" + i)
.attr("text-anchor", "middle")
.attr("startOffset", "50%")
.text(d => d.relationtype === "Distance" && d.value !== "" ? d.value : null)


// define the nodes
var node = svg.selectAll(".node")
    .data(force.nodes())
  .enter().append("g")
    //.attr("class", "node")
    .attr("class", function(d) { return "node " + d.type; })
    .call(force.drag);
node.on("mouseover", mouseover)
	.on("mouseout", mouseout);
// add the nodes
node.append("circle")
 .attr("class", function(d) { return  d.virtual; })
    //.attr("r", 5)
    .attr("r", d => getNodeSize(d));
 ;

// add the text 
node.append("text")
    // .attr("x", 12)
    .attr("x", d => getNodeSize(d) + 7)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; })
    ;

// add the curvy lines
function tick() {
    path.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y;
    });

    node
        .attr("transform", function(d) { 
  	    return "translate(" + d.x + "," + d.y + ")"; });

    // set distance based on node's radius
	path.attr("d", function (d, i) {
		// length of current path
	    const pl = this.getTotalLength();
	    //calculate radius of target node, including the arrow/marker's size 
	    const r = getNodeSize(d.target) + Math.sqrt(6**2 + 6**2);

	    //get the point on the the target node's circumference
	    const m = this.getPointAtLength(pl - r);
	    var dx = d.target.x - d.source.x ,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
	    var result = "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + m.x + "," + m.y;
	    return result;
	});
}

var div = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 1e-6);
	
function mouseover(d) {
	
	d3.select(this).select("circle").transition()
      .duration(750)
      //.attr("r", 16);
      .attr("r", d => getNodeSize(d) * 1.1);
	
	 div.transition()
                .duration(300)
                .style("opacity", 1);
	
   div.text(d.info)
                .style("left", (d3.event.pageX ) + "px")
                .style("top", (d3.event.pageY + 100) + "px");
	
}
	
function mouseout(d) {
  d3.select(this).select("circle").transition()
      .duration(750)
      //.attr("r", 8);
      .attr("r", d => getNodeSize(d));
	
	div.transition()
                .duration(300)
                .style("opacity", 1e-6);
	
}

document.querySelectorAll(".select-activelayer")
.forEach(item => item.addEventListener("click", e => {
	e.preventDefault()
	ACTIVELAYER = e.currentTarget.dataset.layerid;
	const properties = ACTIVELAYER.split("::")
	TYPE_PROPERTY = properties[0]; SIZE_PROPERTY = properties[1];

	//set min and max values by selected properties
	[MIN_VALUE, MAX_VALUE] = getMaxMinValuesFromNodes(nodes)

	force.stop();
	
	node.selectAll("circle").transition().duration(500).attr("r", d => getNodeSize(d))
	node.selectAll("text").transition().duration(500).attr("x", d => getNodeSize(d) + 7)

	force.start();
}))

</script>
</body>
</html>
[%
operation isLayerActive(id : String) {
    var layer = layers.selectOne(l|l.id = id);
    if (layer.isDefined()) {
        return layer.active;
    }
    else {
        return true;
    }
}
%]