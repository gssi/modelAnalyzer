[%var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");%]
<html>
<head>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
</head>
<style>
:root {
  --blue: #60A5FA;
  --green: #6EE7B7;
  --red: #EF4444;
  --dark: #4B5563;
  --dark-2: #1F2937;
}
body, html{
	height: 100%;
	width: 100%;
}
*{
	outline: none;
	margin: 0;
	padding: 0;
	text-shadow: none !important;
}
.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}
.node{
	
}
.node circle {
  /*fill: black;*/
  fill: #00000059;
  stroke: #fff;
  stroke-width: 1.5px;
}

.node.Metamodel circle {
  /*fill: black;
  fill: #00000029;*/
  fill: var(--red);
  stroke: #fff;
  stroke-width: 1.5px;
}

.node.Model circle{
	/*fill: blue;*/
	fill: var(--blue);
	stroke: #fff;
}

circle.virtual{
	fill: #ccc;
}

path.link.dependency {
  	stroke: red;
}

path.link.distance {
  	stroke: violet;
  
}
text {
  font: 10px sans-serif;
  pointer-events: none;
}
.node-label{
	font-size: 12px;
	/*text-anchor: middle;*/
}
.node-label-bg{
	fill: rgb(239, 239, 239);
	/*stroke: #ccc;
    stroke-width: 1;*/
}
div.tooltip {
 	/*
    width: 500px;
    height: 15px;
    padding: 8px;
    font: 10px sans-serif;
    background: lightgray;
    border: solid 1px #ccc;
    */
    position: absolute;
    text-align: center;
    border-radius: 10px;
    pointer-events: none;
    padding: 10px 15px;
    font: 14px sans-serif;
    background: #fff;
    border: solid 1px #ededed;
}
            
.jumbotron {
	background-color:#FFFFFF;
	padding: 0 !important;
    margin: 0 !important;
}
.custom-navbar{
	box-shadow: none;
    background: #fff;
    border-radius: 10px;
    margin-top: 15px;
}
.custom-navbar.dark-theme{
	background: var(--dark)
}
.custom-navbar.dark-theme.navbar-default .navbar-brand{
	color: #fff;
}
.custom-navbar .dropdown .dropdown-toggle{
    padding: 10px 15px;
    border-radius: 5px;
    box-shadow: none;
    background: none;
    transition: 0.5s;
    margin: 5px 5px 0;
}
.custom-navbar .navbar-nav > li > a{
    font-size: 16px;
}
.custom-navbar.dark-theme .navbar-nav > li > a{
	color: #fff;
}
.custom-navbar .dropdown .dropdown-toggle:hover, .custom-navbar .dropdown.open .dropdown-toggle{
	background: #ededed;
}
.custom-navbar.dark-theme .dropdown .dropdown-toggle:hover, .custom-navbar.dark-theme .dropdown.open .dropdown-toggle{
	background: var(--dark-2);
	color: #fff;
}
.custom-navbar .dropdown-menu{
	background: var(--dark)
}
.custom-navbar .dropdown-menu>li{
	padding: 5px 10px;
	font-size: 16px;
}
.custom-navbar .dropdown-menu>li>a{
    padding: 10px 15px;
    border-radius: 5px;
    transition: 0.5s;
}
.custom-navbar.dark-theme .dropdown-menu>li>a{
	color: #fff;
}
.custom-navbar .dropdown-menu>li>a:hover, .custom-navbar .dropdown-menu>li>a:focus{
	/*background: #ededed;*/
	background: var(--green);
	color: #fff;
}
.custom-navbar .navbar-nav>li>.dropdown-menu{
	border: 1px solid #ededed;
    border-radius: 10px;
    margin-top: 10px;
}
/* OVERLAY NAVBAR */
#main-wrapper{
	position: absolute;
	top: 0;
    left: 50%;
    transform: translateX(-50%);
}
.tooltip.custom-tooltip{
	position: absolute;
	bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 1.5em;
    background: var(--green);
    color: #fff;
}
</style>
<body>
<div class="container">

      <!-- Static navbar -->
  <nav class="navbar navbar-default custom-navbar dark-theme">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">Repository Explorer</a>
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li><a href="#" class="select-activelayer" data-layerid="A::A">Reset</a></li>
              [%for (a	 in nodes.eClass.name.asSet()) { %]
				<li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">[%=a%] <span class="caret"></span></a>
                <ul class="dropdown-menu">
                [%for (qa in evals.qa.select(q|q.subject.name==a).name.asSet()) { %]
                  <li><a href="#" class="select-activelayer" data-layerid="[%=a%]::[%=qa%]">[%=qa%]</a></li>   
                  [%}%]          
             </ul>
              </li>
				[%}%]
            </ul>
            
          </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
      </nav>

      <!-- Main component for a primary marketing message or call to action -->
      <div class="jumbotron" id="repo">
        
      </div>

    </div> <!-- /container -->

<script src="https://d3js.org/d3.v3.min.js"></script>
<script>

var links = [
[%for (edge in edges) { 
if(edge.src.isDefined() and edge.trg.isDefined()){
%]
  {source: "[%=edge.src.name%]", target: "[%=edge.trg.name%]", type: "unidirectional", relationtype: "[%=edge.eClass.name%]", value: "[%=(edge.eClass.name='Distance')?edge.value:''%]"},
  [%
 	}}
  %]
];

    
var nodes = {
[%for (node in nodes) { %]
	"[%=node.name%]" : {"name":"[%=node.name%]","type":"[%=node.eClass.name%]","info":"[%=node.name%]","virtual":"[%=(node.virtual)?"virtual":"concrete"%]" 
	[% if(evals.size()>0){ %]
	,
	quality: {[% for(e in evals.select(ev|emfTool.EcoreUtil.equals(node, ev.subject))){ %]
	 "[%=e.qa.name%]":"[%=e.actualizedvalue%]",
	 [%}%]}
	[%}%]	 
	},
[%}%]

 };

const container = document.getElementById("main-wrapper"), repo = document.getElementById("repo")
const width = window.innerWidth, // container.clientWidth - (parseFloat(getComputedStyle(container).paddingLeft) * 2),
	height = window.innerHeight // - repo.offsetTop;

const MIN_LINK_DISTANCE = 200,
	  MIN_NODE_SIZE = 5, MAX_NODE_SIZE = 30;

const backgroundNodeLabel = "#6EE7B7";

let ACTIVELAYER = "A::A", checkClick = false;
let [TYPE_PROPERTY, SIZE_PROPERTY] = ACTIVELAYER.split("::")

let MAX_VALUE, MIN_VALUE;

const getMaxMinValuesFromNodes = (nodes) => {
	//default values
	const default_values = [0, 100]
	let parse_nodes;
  	//can be used either nodes object or force.nodes() array
  	Array.isArray(nodes) ?  parse_nodes = nodes : parse_nodes = Object.values(nodes)

	const filter_array = parse_nodes.filter(item => item.type == TYPE_PROPERTY ? +item[SIZE_PROPERTY] : null)
	
	//check if there are enough objects with valid SIZE_PROPERTY values
	if(filter_array < 2) return default_values

	const sorted_array = filter_array.sort((prev, current) => prev[SIZE_PROPERTY] - current[SIZE_PROPERTY])
	const min = +sorted_array[0][SIZE_PROPERTY], max = +sorted_array[sorted_array.length-1][SIZE_PROPERTY]

	return min && max ? [min, max] : default_values
}

//get integer number between
const getRelativeValue = (n, round) => round ? Math.round((n*MAX_NODE_SIZE)/MAX_VALUE) : (n*MAX_NODE_SIZE)/MAX_VALUE

//get a valid numeric value from SIZE_PROPERTY property 
const getNodeSize = d => {	
	const value = d[SIZE_PROPERTY], type = d.type;

	//check type, if it's not TYPE_PROPERTY return default size
	if(type !== TYPE_PROPERTY){
		return MIN_NODE_SIZE
	}
	
	//type is ok, then node's size depends on d.SIZE_PROPERTY's value

	//check if value is a number, null or undefined
	const num = +value ? +value : 0;
	
	//get relative value
	const rel = getRelativeValue(num)

	return rel + MIN_NODE_SIZE
}

//set distance for each edge, adding an offset based on nodes' size
const linkDistanceByNodeSize = d => {
	let offset = 0;

	//get source node offset
	const source_offset = getNodeSize(d.source)
	if(source_offset > MIN_NODE_SIZE) offset += source_offset

	//get target node offset
	const target_offset = getNodeSize(d.target)
	if(target_offset > MIN_NODE_SIZE) offset += target_offset

	return offset + MIN_LINK_DISTANCE
}

//init min and max values
[MIN_VALUE, MAX_VALUE] = getMaxMinValuesFromNodes(nodes)

links.forEach(function(link) {
    link.source = nodes[link.source] || 
        (nodes[link.source] = {name: link.source});
    link.target = nodes[link.target] || 
        (nodes[link.target] = {name: link.target});
    link.value = +link.value;
});



var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    //.linkDistance(60)
    .linkDistance(linkDistanceByNodeSize)
    .charge(-500)
    //.charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("div#repo").append("svg")
    .attr("width", width)
    .attr("height", height);

// build the arrow.
svg.append("svg:defs").selectAll("marker")
    .data(["end"])      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    //.attr("refX", 15)
    //.attr("refY", -1.5) 
    .attr("refX", 0)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

// add the links and the arrows
var path = svg.append("svg:g").selectAll("path")
    .data(force.links())
  .enter().append("svg:path")
    .attr("class", function(d) { return "link " + d.relationtype; })
    //.attr("class", "link")
     .attr("id", (d, i) => "path_" + i)
  .style("stroke-dasharray", ("3, 3"))
 .attr("marker-end", link => link.type === "unidirectional" ? "url(#end)" : 0)
 ;
 
//TEXTPATH
svg.append("g").selectAll("text")
.data(force.links())
.enter()
.append("text")
.append("textPath")
.attr("xlink:href", (d,i) => "#path_" + i)
.attr("text-anchor", "middle")
.attr("startOffset", "50%")
.text(d => d.relationtype === "Distance" && d.value !== "" ? d.value : null)


// define the nodes
var node = svg.selectAll(".node")
    .data(force.nodes())
  .enter().append("g")
    //.attr("class", "node")
    .attr("class", function(d) { return "node " + d.type; })
    .call(force.drag);

node.on("mouseenter", mouseover)
	//.on("mouseout", mouseout)
	//.on("mouseover", mouseover)
	.on("mouseleave", mouseout)
	.on("mousedown", mousedown)
	.on("mouseup", mouseup);

// add the nodes
node.append("circle")
 .attr("class", function(d) { return  d.virtual; })
    //.attr("r", 5)
    .attr("r", d => getNodeSize(d));
 ;

// add the text 
const nodeLabel = node.append("text")
    // .attr("x", 12)
    .attr("x", d => getNodeSize(d) + 7)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; })
    .attr("class", d => "node-label")
    .call(getTextBox);

//add background text
const bgNodeLabel = node.insert("rect", "text")
    .attr("rx", 10)
    .attr("class", "node-label-bg")
    //.style("fill", "#efefef")
    .attr("x", d => d.bbox.x - 2.5) 
    .attr("y", d => -d.bbox.height)
    //.attr("width", d => {debugger})
    .attr("width", d => d.bbox.width + 10)
    .attr("height", d => d.bbox.height*2)
	;

function getTextBox(selection){
    selection.each(function(d) { d.bbox = this.getBBox(); })
}

d3.selection.prototype.moveToFront = function() {  
	return this.each(function(){
		this.parentNode.appendChild(this);
	});
};

// add the curvy lines
function tick() {
    path.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y;
    });

    node
        .attr("transform", function(d) { 
  	    return "translate(" + d.x + "," + d.y + ")"; })

    

    // set distance based on node's radius
	path.attr("d", function (d, i) {
		// length of current path
	    const pl = this.getTotalLength();

	    //calculate radius of target node, including the arrow/marker's size 
	    const r = getNodeSize(d.target) + Math.sqrt(6**2 + 6**2);

	    //get the point on the the target node's circumference
	    const m = this.getPointAtLength(pl - r);
	    var dx = d.target.x - d.source.x ,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);

	    var result = "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + m.x + "," + m.y;

	    return result;
	});
}

var div = d3.select("body").append("div")
        .attr("class", "tooltip custom-tooltip")
        .style("opacity", 0);

function mousedown(d) {
	checkClick = true;
}

function mouseup(d) {
	checkClick = false;
}

function mouseover(d) {
	//ignore if node is clicked
	if(checkClick){
		return
	}
	//if it's not, bring node to front
	d3.select(this).moveToFront()

	d3.select(this).select("circle").transition()
      .duration(750)
      //.attr("r", 16);
      .attr("r", d => getNodeSize(d) * 1.2);

    //INCREASE FONT SIZE
	/*const labels = d3.select(this).select("text")
		.style("opacity", 0)
		.style("font-size", "16px")
		.attr("fill", "#fff")
		.call(getTextBox);*/

	//d3.select(this).select("rect").transition().duration(300).style("opacity", 1)
	
	div.transition()
        .duration(300)
        .style("opacity", 1);
	
   	div.text(d.info)
        //.style("left", (d3.event.pageX ) + "px")
        //.style("top", (d3.event.pageY + 100) + "px");
        .style("opacity", 1)
	
}
	
function mouseout(d) {

	//ignore if node is clicked
	if(checkClick){
		return
	}
	
	d.front = false;

  	d3.select(this).select("circle").transition()
      .duration(750)
      //.attr("r", 8);
      .attr("r", d => getNodeSize(d));
	
	//d3.select(this).select("rect").transition().duration(300).style("opacity", 0.8)

	div.transition()
                .duration(300)
                .style("opacity", 1e-6);
	
}

document.querySelectorAll(".select-activelayer")
.forEach(item => item.addEventListener("click", e => {
	e.preventDefault()
	ACTIVELAYER = e.currentTarget.dataset.layerid;
	const properties = ACTIVELAYER.split("::")
	TYPE_PROPERTY = properties[0]; SIZE_PROPERTY = properties[1];

	//set min and max values by selected properties
	[MIN_VALUE, MAX_VALUE] = getMaxMinValuesFromNodes(nodes)

	force.stop();
	
	node.selectAll("circle").transition().duration(500).attr("r", d => getNodeSize(d))
	node.selectAll("text").attr("x", d => getNodeSize(d) + 7).call(getTextBox)
	node.selectAll("rect")
		.attr("x", d => d.bbox.x - 2.5) 
	    .attr("y", d => -d.bbox.height)
	    .attr("width", d => d.bbox.width + 10)
	    .attr("height", d => d.bbox.height*2)

	force.start();
}))

</script>
</body>
</html>
[%
operation isLayerActive(id : String) {
    var layer = layers.selectOne(l|l.id = id);
    if (layer.isDefined()) {
        return layer.active;
    }
    else {
        return true;
    }
}
%]